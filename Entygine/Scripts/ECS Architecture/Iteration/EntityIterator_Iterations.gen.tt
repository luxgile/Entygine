<#@ template hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Collections" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Runtime.CompilerServices" #>
using System.Runtime.CompilerServices;

namespace Entygine.Ecs
{
    public static class GeneratedIterators
    {
<#
//I'm sorry to anyone who reads this in the future, I'm really sorry.

int parameters = 0;
List<string> AllModeCombinationsFor(int amount)
{
    if (amount == 0)
        return new List<string>() { "" };

    var oneFewerResult = AllModeCombinationsFor(amount - 1);

    return oneFewerResult.SelectMany(oldResult =>
        {
            if (oldResult == "")
            {
                return new List<string>() { "R","W" };
            }
            var result = new List<string>()
            {
                oldResult+"W"
            };
            char lastChar = oldResult[oldResult.Length-1];
            if (lastChar == 'R')
                result.Add(oldResult+"R");

            return result;
        }).ToList();
}
List<string> combinations = new List<string>();
for(int i = 1; i < parameters; i++)
{
    combinations.AddRange(AllModeCombinationsFor(i));
}

foreach(var str in combinations) 
{
#>          public delegate void <#= str #><<#
for(int i = 0; i < str.Length; i++)
{
char c = str[i];
if(c == 'R') { #>C<#= i #><# }
if(c == 'W') { #>C<#= i #><# }
if(i != str.Length - 1) {#>, <#}
}
#>>(<# 

for(int i = 0; i < str.Length; i++)
{
char c = str[i];
if(c == 'R') { #>in C<#= i #> read<#= i #><# }
if(c == 'W') { #>ref C<#= i #> write<#= i #><# }
if(i != str.Length - 1) {#>, <#}
}
#>)
            <# 
for(int i = 0; i < str.Length; i++)
{
char c = str[i];#>
where C<#= i #> : struct, IComponent <#
} 
#>;
<#
}
#>
    }

    public partial class EntityIterator
    {
<#
foreach(var str in combinations) 
{
    #>          public IIteratorPhase2 Iterate<<#
    for(int i = 0; i < str.Length; i++)
    {
        char c = str[i];
        #>C<#= i #><#
        if(i != str.Length - 1)
        {
            #>, <#
        }
    }
    #>> (GeneratedIterators.<#=str#><<#
    for(int i = 0; i < str.Length; i++)
    {
        char c = str[i];
        #>C<#= i #><#
        if(i != str.Length - 1)
        {
            #>, <#
        }
    }
    #>> iterator) <# 
for(int i = 0; i < str.Length; i++)
{
char c = str[i];#>
where C<#= i #> : struct, IComponent <#
} 
#>

            {
<#
for(int i = 0; i < str.Length; i++)
{
char c = str[i];#>
            TypeId id<#=i#> = TypeManager.GetIdFromType(typeof(C<#=i#>));
            AddType(withTypes, id<#=i#>);
<#
}#>
            BakeSettings();
            SetDelegate((chunk) =>
            {
<#
for(int i = 0; i < str.Length; i++)
{
char c = str[i];#>              chunk.TryGetComponents(id<#=i#>, out ComponentArray collection<#=i#>);
<#
}#>
                for (int e = 0; e < chunk.Count; e++)
                {
                    iterator(<#
for(int i = 0; i < str.Length; i++)
{
char c = str[i];
if(c == 'R') { #>in Unsafe.Unbox<C<#=i#>>(collection<#=i#>[e])<# }
if(c == 'W') { #>ref Unsafe.Unbox<C<#=i#>>(collection<#=i#>[e])<# }
if(i != str.Length - 1) {#>, <#}
}
#>);
                }
            });
            
            return this;
            }
<#
}
#>
    }
}